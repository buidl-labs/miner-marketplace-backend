// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
	"time"
)

type Contact struct {
	Email   *string `json:"email"`
	Slack   *string `json:"slack"`
	Website *string `json:"website"`
	Twitter *string `json:"twitter"`
}

type Deadline struct {
	ID            string `json:"id"`
	DeadlineIndex int    `json:"deadlineIndex"`
	PeriodStart   int    `json:"periodStart"`
	Open          int    `json:"open"`
	Close         int    `json:"close"`
	Challenge     int    `json:"challenge"`
	FaultCutoff   int    `json:"faultCutoff"`
}

type DeadlineOrderByInput struct {
	Deadline *Sort `json:"deadline"`
}

type Expenditure struct {
	NetworkFee *float64 `json:"networkFee"`
	Penalty    *float64 `json:"penalty"`
}

type Fault struct {
	Type      *FaultType `json:"type"`
	Penalty   *Penalty   `json:"penalty"`
	Height    int        `json:"height"`
	Timestamp *time.Time `json:"timestamp"`
}

type FinanceMetrics struct {
	Miner       *Miner       `json:"miner"`
	Income      *Income      `json:"income"`
	Expenditure *Expenditure `json:"expenditure"`
	Funds       *Funds       `json:"funds"`
}

type Fun struct {
	ID   string `json:"id"`
	Meta string `json:"meta"`
	Text string `json:"text"`
}

type Funds struct {
	PreCommitDeposits float64 `json:"preCommitDeposits"`
	InitialPledge     float64 `json:"initialPledge"`
	LockedFunds       float64 `json:"lockedFunds"`
	AvailableFunds    float64 `json:"availableFunds"`
}

type Income struct {
	Total                 *float64 `json:"total"`
	BlockRewards          *float64 `json:"blockRewards"`
	StorageDealPayments   *float64 `json:"storageDealPayments"`
	RetrievalDealPayments *float64 `json:"retrievalDealPayments"`
}

type Miner struct {
	ID                   string               `json:"id"`
	Address              string               `json:"address"`
	PeerID               string               `json:"peerId"`
	Owner                *Owner               `json:"owner"`
	Worker               *Worker              `json:"worker"`
	Name                 *string              `json:"name"`
	Bio                  *string              `json:"bio"`
	Contact              *Contact             `json:"contact"`
	Verified             bool                 `json:"verified"`
	ServiceDetails       *ServiceDetails      `json:"serviceDetails"`
	QualityIndicators    *QualityIndicators   `json:"qualityIndicators"`
	FinanceMetrics       *FinanceMetrics      `json:"financeMetrics"`
	AllServiceDetails    []*ServiceDetails    `json:"allServiceDetails"`
	AllQualityIndicators []*QualityIndicators `json:"allQualityIndicators"`
	AllFinanceMetrics    []*FinanceMetrics    `json:"allFinanceMetrics"`
	StorageDeal          *StorageDeal         `json:"storageDeal"`
	Transaction          *Transaction         `json:"transaction"`
	Sector               *Sector              `json:"sector"`
	Penalty              *Penalty             `json:"penalty"`
	Deadline             *Deadline            `json:"deadline"`
	StorageDeals         []*StorageDeal       `json:"storageDeals"`
	Transactions         []*Transaction       `json:"transactions"`
	Sectors              []*Sector            `json:"sectors"`
	Penalties            []*Penalty           `json:"penalties"`
	Deadlines            []*Deadline          `json:"deadlines"`
}

type NewTodo struct {
	Text   string `json:"text"`
	UserID string `json:"userId"`
}

type Owner struct {
	ID                  string  `json:"id"`
	Miner               *Miner  `json:"miner"`
	Address             string  `json:"address"`
	Actor               *Actor  `json:"actor"`
	Balance             float64 `json:"balance"`
	Messages            *int    `json:"messages"`
	CreatedAt           *int    `json:"createdAt"`
	LatestTransactionAt *int    `json:"latestTransactionAt"`
}

type PageInfo struct {
	HasNextPage     bool    `json:"hasNextPage"`
	HasPreviousPage bool    `json:"hasPreviousPage"`
	StartCursor     *string `json:"startCursor"`
	EndCursor       *string `json:"endCursor"`
}

type Penalty struct {
	ID        string       `json:"id"`
	Fee       float64      `json:"fee"`
	Type      *PenaltyType `json:"type"`
	Height    int          `json:"height"`
	Timestamp *time.Time   `json:"timestamp"`
}

type QualityIndicators struct {
	QualityAdjPower      *float64 `json:"qualityAdjPower"`
	RawBytePower         *float64 `json:"rawBytePower"`
	QualityAdjPowerRatio *float64 `json:"qualityAdjPowerRatio"`
	RawBytePowerRatio    *float64 `json:"rawBytePowerRatio"`
	WinCount             *int     `json:"winCount"`
	FaultySectors        *int     `json:"faultySectors"`
	DataStored           *float64 `json:"dataStored"`
	BlocksMined          *int     `json:"blocksMined"`
	FeeDebt              *float64 `json:"feeDebt"`
	MiningEfficiency     *int     `json:"miningEfficiency"`
}

type Sector struct {
	ID              string       `json:"id"`
	Miner           *Miner       `json:"miner"`
	Size            float64      `json:"size"`
	QualityAdjPower float64      `json:"qualityAdjPower"`
	State           *SectorState `json:"state"`
	InitialPledge   *float64     `json:"initialPledge"`
	Faults          []*Fault     `json:"faults"`
}

type ServiceDetails struct {
	Storage           *bool    `json:"storage"`
	Retrieval         *bool    `json:"retrieval"`
	Repair            *bool    `json:"repair"`
	OnlineDeals       *bool    `json:"onlineDeals"`
	OfflineDeals      *bool    `json:"offlineDeals"`
	StorageAskPrice   *float64 `json:"storageAskPrice"`
	RetrievalAskPrice *float64 `json:"retrievalAskPrice"`
	MinPieceSize      *int     `json:"minPieceSize"`
	MaxPieceSize      *int     `json:"maxPieceSize"`
}

type StorageDeal struct {
	ID            string  `json:"id"`
	Miner         *Miner  `json:"miner"`
	MessageID     string  `json:"messageId"`
	ClientID      string  `json:"clientId"`
	ClientAddress string  `json:"clientAddress"`
	Price         float64 `json:"price"`
	StartEpoch    int     `json:"startEpoch"`
	EndEpoch      int     `json:"endEpoch"`
	Duration      int     `json:"duration"`
	PieceSize     int     `json:"pieceSize"`
	PieceCid      string  `json:"pieceCID"`
	Verified      *bool   `json:"verified"`
}

type Transaction struct {
	ID              string           `json:"id"`
	Miner           *Miner           `json:"miner"`
	TransactionType *TransactionType `json:"transactionType"`
	Amount          float64          `json:"amount"`
	Sender          string           `json:"sender"`
	Receiver        string           `json:"receiver"`
	Height          int              `json:"height"`
	Timestamp       *time.Time       `json:"timestamp"`
	NetworkFee      *float64         `json:"networkFee"`
}

type User struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

type Worker struct {
	ID                  string  `json:"id"`
	Miner               *Miner  `json:"miner"`
	Address             string  `json:"address"`
	Actor               *Actor  `json:"actor"`
	Balance             float64 `json:"balance"`
	Messages            *int    `json:"messages"`
	CreatedAt           *int    `json:"createdAt"`
	LatestTransactionAt *int    `json:"latestTransactionAt"`
}

type Actor string

const (
	ActorStorageMiner   Actor = "STORAGE_MINER"
	ActorRetrievalMiner Actor = "RETRIEVAL_MINER"
	ActorAccount        Actor = "ACCOUNT"
)

var AllActor = []Actor{
	ActorStorageMiner,
	ActorRetrievalMiner,
	ActorAccount,
}

func (e Actor) IsValid() bool {
	switch e {
	case ActorStorageMiner, ActorRetrievalMiner, ActorAccount:
		return true
	}
	return false
}

func (e Actor) String() string {
	return string(e)
}

func (e *Actor) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Actor(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Actor", str)
	}
	return nil
}

func (e Actor) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type FaultType string

const (
	FaultTypeDeclared FaultType = "DECLARED"
	FaultTypeDetected FaultType = "DETECTED"
	FaultTypeSkipped  FaultType = "SKIPPED"
)

var AllFaultType = []FaultType{
	FaultTypeDeclared,
	FaultTypeDetected,
	FaultTypeSkipped,
}

func (e FaultType) IsValid() bool {
	switch e {
	case FaultTypeDeclared, FaultTypeDetected, FaultTypeSkipped:
		return true
	}
	return false
}

func (e FaultType) String() string {
	return string(e)
}

func (e *FaultType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FaultType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FaultType", str)
	}
	return nil
}

func (e FaultType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PenaltyType string

const (
	PenaltyTypePrecommitExpiryPenalty  PenaltyType = "PRECOMMIT_EXPIRY_PENALTY"
	PenaltyTypeUndeclaredFaultPenalty  PenaltyType = "UNDECLARED_FAULT_PENALTY"
	PenaltyTypeDeclaredFaultPenalty    PenaltyType = "DECLARED_FAULT_PENALTY"
	PenaltyTypeOngoingFaultPenalty     PenaltyType = "ONGOING_FAULT_PENALTY"
	PenaltyTypeTerminationFaultPenalty PenaltyType = "TERMINATION_FAULT_PENALTY"
	PenaltyTypeConsensusFaultPenalty   PenaltyType = "CONSENSUS_FAULT_PENALTY"
)

var AllPenaltyType = []PenaltyType{
	PenaltyTypePrecommitExpiryPenalty,
	PenaltyTypeUndeclaredFaultPenalty,
	PenaltyTypeDeclaredFaultPenalty,
	PenaltyTypeOngoingFaultPenalty,
	PenaltyTypeTerminationFaultPenalty,
	PenaltyTypeConsensusFaultPenalty,
}

func (e PenaltyType) IsValid() bool {
	switch e {
	case PenaltyTypePrecommitExpiryPenalty, PenaltyTypeUndeclaredFaultPenalty, PenaltyTypeDeclaredFaultPenalty, PenaltyTypeOngoingFaultPenalty, PenaltyTypeTerminationFaultPenalty, PenaltyTypeConsensusFaultPenalty:
		return true
	}
	return false
}

func (e PenaltyType) String() string {
	return string(e)
}

func (e *PenaltyType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PenaltyType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PenaltyType", str)
	}
	return nil
}

func (e PenaltyType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SectorState string

const (
	SectorStatePrecommited SectorState = "PRECOMMITED"
	SectorStateCommitted   SectorState = "COMMITTED"
	SectorStateActive      SectorState = "ACTIVE"
	SectorStateFaulty      SectorState = "FAULTY"
	SectorStateRecovering  SectorState = "RECOVERING"
	SectorStateTerminated  SectorState = "TERMINATED"
)

var AllSectorState = []SectorState{
	SectorStatePrecommited,
	SectorStateCommitted,
	SectorStateActive,
	SectorStateFaulty,
	SectorStateRecovering,
	SectorStateTerminated,
}

func (e SectorState) IsValid() bool {
	switch e {
	case SectorStatePrecommited, SectorStateCommitted, SectorStateActive, SectorStateFaulty, SectorStateRecovering, SectorStateTerminated:
		return true
	}
	return false
}

func (e SectorState) String() string {
	return string(e)
}

func (e *SectorState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SectorState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SectorState", str)
	}
	return nil
}

func (e SectorState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Sort string

const (
	SortAsc  Sort = "asc"
	SortDesc Sort = "desc"
)

var AllSort = []Sort{
	SortAsc,
	SortDesc,
}

func (e Sort) IsValid() bool {
	switch e {
	case SortAsc, SortDesc:
		return true
	}
	return false
}

func (e Sort) String() string {
	return string(e)
}

func (e *Sort) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Sort(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Sort", str)
	}
	return nil
}

func (e Sort) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TransactionDirection string

const (
	TransactionDirectionIncoming TransactionDirection = "INCOMING"
	TransactionDirectionOutgoing TransactionDirection = "OUTGOING"
)

var AllTransactionDirection = []TransactionDirection{
	TransactionDirectionIncoming,
	TransactionDirectionOutgoing,
}

func (e TransactionDirection) IsValid() bool {
	switch e {
	case TransactionDirectionIncoming, TransactionDirectionOutgoing:
		return true
	}
	return false
}

func (e TransactionDirection) String() string {
	return string(e)
}

func (e *TransactionDirection) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TransactionDirection(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TransactionDirection", str)
	}
	return nil
}

func (e TransactionDirection) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TransactionType string

const (
	TransactionTypeStorageDeal   TransactionType = "STORAGE_DEAL"
	TransactionTypeRetrievalDeal TransactionType = "RETRIEVAL_DEAL"
	TransactionTypeBlockReward   TransactionType = "BLOCK_REWARD"
	TransactionTypeNetworkFee    TransactionType = "NETWORK_FEE"
	TransactionTypePenalty       TransactionType = "PENALTY"
)

var AllTransactionType = []TransactionType{
	TransactionTypeStorageDeal,
	TransactionTypeRetrievalDeal,
	TransactionTypeBlockReward,
	TransactionTypeNetworkFee,
	TransactionTypePenalty,
}

func (e TransactionType) IsValid() bool {
	switch e {
	case TransactionTypeStorageDeal, TransactionTypeRetrievalDeal, TransactionTypeBlockReward, TransactionTypeNetworkFee, TransactionTypePenalty:
		return true
	}
	return false
}

func (e TransactionType) String() string {
	return string(e)
}

func (e *TransactionType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TransactionType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TransactionType", str)
	}
	return nil
}

func (e TransactionType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
